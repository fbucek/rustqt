/* generated by rust_qt_binding_generator */
#include "rocksdb.h"

namespace {

    typedef void (*qstring_set)(QString* val, const char* utf8, int nbytes);
    void set_qstring(QString* val, const char* utf8, int nbytes) {
        *val = QString::fromUtf8(utf8, nbytes);
    }
    inline void databasePathChanged(Database* o)
    {
        Q_EMIT o->pathChanged();
    }
}
extern "C" {
    Database::Private* database_new(Database*, void (*)(Database*));
    void database_free(Database::Private*);
    void database_path_get(const Database::Private*, QString*, qstring_set);
    void database_path_set(Database::Private*, const ushort *str, int len);
    void database_add_value(Database::Private*, const ushort*, int, const ushort*, int);
    void database_get_value(const Database::Private*, const ushort*, int, QString*, qstring_set);
};

Database::Database(bool /*owned*/, QObject *parent):
    QObject(parent),
    m_d(nullptr),
    m_ownsPrivate(false)
{
}

Database::Database(QObject *parent):
    QObject(parent),
    m_d(database_new(this,
        databasePathChanged)),
    m_ownsPrivate(true)
{
}

Database::~Database() {
    if (m_ownsPrivate) {
        database_free(m_d);
    }
}
QString Database::path() const
{
    QString v;
    database_path_get(m_d, &v, set_qstring);
    return v;
}
void Database::setPath(const QString& v) {
    database_path_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
}
void Database::addValue(const QString& key, const QString& value)
{
    return database_add_value(m_d, key.utf16(), key.size(), value.utf16(), value.size());
}
QString Database::getValue(const QString& key) const
{
    QString s;
    database_get_value(m_d, key.utf16(), key.size(), &s, set_qstring);
    return s;
}
